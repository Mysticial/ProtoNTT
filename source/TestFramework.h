/* TestFramework.h
 * 
 * Author           : Alexander J. Yee
 * Date Created     : 11/06/2014
 * Last Modified    : 11/15/2014
 * 
 */

#pragma once
#ifndef _ntt_TestFramework_H
#define _ntt_TestFramework_H
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#ifdef _MSC_VER
#pragma warning(disable:4127)   //  Constant Expression
#endif
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#include <string>
#include "Internals/ArchIntrinsics.h"
namespace ProtoNTT{
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void pause();
void print_commas(uint64_t x);
void print_bits(uint64_t bits);
void print_words(uint64_t words);
void print_bytes(uint64_t bytes);
double wall_clock();
void print(const uint64_t* A, size_t L);
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Checksum Hashing using mod 2^61 - 1. (Mersenne Prime)
FORCE_INLINE uint64_t hash_reduce(uint64_t L, uint64_t H){
    //  Computes: (L + H * 2^64) mod (2^61 - 1)

    //Conditions:
    //  -   H < 2^61

    H <<= 3;
    H |= L >> 61;
    L &= 0x1fffffffffffffffull;
    L += H;
    H = L - 0x1fffffffffffffffull;
    return L >= 0x1fffffffffffffffull ? H : L;
}
inline uint64_t hash_compute(const uint64_t* T, size_t L){
    //  Computes: T % (2^61 - 1)

    uint64_t x = 0;
    T += L;
    while (L > 0){
        L--;
        uint64_t a = *--T;

        uint64_t t = x >> 32;
        x <<= 32;
        x |= (uint32_t)(a >> 32);

        x = hash_reduce(x, t);

        t = x >> 32;
        x <<= 32;
        x |= (uint32_t)a;

        x = hash_reduce(x, t);
    }

    return x;
}
inline uint64_t hash_mul(uint64_t a, uint64_t b){
    //  Computes: a * b mod (2^61 - 1)

    //Conditions:
    //  -   A < 2^61 - 1
    //  -   B < 2^61 - 1

    mulF(a, b, a, b);
    return hash_reduce(a, b);
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Checksum Hashing using mod 2^61 - 1. (Mersenne Prime)
FORCE_INLINE uint64_t random(uint64_t index){
    //  A very crude random number generator.
    index += 2760733047673ull;
    return (uint64_t)2760727302517*index*index*index + 2760730175003ull;
}
inline void random(uint64_t* T, size_t L, uint64_t index = 0){
    for (size_t c = 0; c < L; c++){
        *T++ = random(index + c);
    }
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
}
#endif
